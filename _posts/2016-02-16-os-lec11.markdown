---
layout: post
title:  "OS Lecture 11"
date:   2016-02-16 14:30:00 -0500
categories: cs580
---


* MT scheduler
	* ![](/images/OSLEC11A.png)
	* 
## CPU Bursts
* ![](/images/OSLEC11B.png)
* predicted burst time
* job time
* 다 저장해서 벌스트 예측하기 힘들다
* 솔루션: 
	* $t_n$ = length of n-th burst
	* $\tau_n$ = approx to n-th burst
	* $\tau_{n+1}$ : $t_n$을 보고 예측함
	* $\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n$
		* $\alpha t_n + (1-\alpha)(\alpha t_{n-1} + (1-\alpha)\tau_{n-1})$
		* $\alpha t_n + (1-\alpha)\alpha t_{n-1} + (1-\alpha)^2\tau_{n-1}$
	* $\tau_{n+2} = \alpha*t_{n+1} + (1-\alpha)\tau_{n+1}$


### Algorithms

* FCFS
	* first come first serve
	* simple but bad waiting tiem
	* example, 
		* A(24) ,B(3) ,C(3)
			* waiting time - A(0) ,B(24) ,C(27) = 51/3 = 17
		* B(3) ,C(3), A(24)
		 	* waiting time - A(6) ,B(0) ,C(3) = 9/3 = 3

		 	
* SJF
	* shortest job first
	* provably minimizes average waiting time
	* scatch of proof
		* ![](/images/OSLEC1C.png)
	* starvation - 작은게 계속 들어오면 크놈은 절대 실행못함
		* aging 
* Priority Queing
	* takes p an associates with job time 1/p - SJF
* Round-robin scheduling
	* establish a quantum (unit of time)
	* quantum size
		* long compared with context switch time
		* short enough not to degrade response time

		* Example
			* Target Response Time
				* <= 200ms
			* LAV = load average - avg # processes in run queue
				* if it is 5, 
			* Quantum<=40ms
	* want a quantum that approximates the burst time AVG
		* Example
			* A(10), B(10), C(10)
			* assume cst is very small
			* quantum=10
				* wait time A(0), B(10), C(20) = 30/3 = 10			* quantum=1
				* ABC, ABC, ABC, ...
				* wait time A(0), B(1), C(2)  A(2), B(2), C(2)
					* 3 6 6 ...6  = 57
* Multilevel Q's
	* High(small quantum), Med(med quantum), Low(large quantum)
	* run Q's from high to low, 
	* moving down when a Q is empty
* Multilevel feedback Q's
	* If a process uses its full quantum, drop it down a queue
	* If a process uses lees than its quantum, move it up
	
