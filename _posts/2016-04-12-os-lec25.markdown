---
layout: post
title:  "OS Lecture 25"
date:   2016-04-12 14:30:00 -0500
categories: cs580
---



## 핸드아웃
![](http://bgshin.github.io/images/OSLEC25A.png)

## Disk manager
* order requests to minimize average access time
* ie., minimize seek distance
* Algorithms
	* FCFS - first come first serve
		* ex) 1000(*) 2 999 3 998
			* 998 997 996 995
		* simple
		* expansive on seek distance
	* SSTF - shortest seek time first
		* pick the requiest closest to where you are now
		* ex) 1000(*) 2 999 3 998
			* 1000->999->998->3->2
			* 1 1 995 1
		* Q: SSTF가 증명적으로 토털 디스턴스에서의 optimal인가?
			* 100(*) 150 49 300 
			* 100->150->49->300
			* 50 101 251 = 402
			* 근데 100(*) 49 150 300 이러면 
			* 51 101 150 = 302 더작다
			* 그래서 optimal은 아님
		* starvation - 먼곳에 있는놈은 서비스 못받음 (aging필요)
	* SCAN (Elevator alg)
		* go to the closest request in the current direction
		* if there are none, reverse direction
	* CSCAN - circular scan
		* up is the only direction for servicing requests
		* if there are no more requests above start at the bottom again

		
## Allocation
* pure demand paging
	* 1 free pool (global)
	* each process handles faults from it
	* amount of frames allocated to a process increases with the number of page faults
* In practice may want is policy that determines the number of pages allocated for a process
	* priority
	* virtual size
	* fair 1/N
* if a process is given too small an allocation, the system thrashes
* W_{delta}(p) working set of a process during interval delta
	* the set of pages referenced during that interval
	* |W_{delta}(p)| working set size
	* to avoid thrashing need to allocate at least the working set size
* working set algorithm 
	* calculate \sum{for all p in RQ} |W_{delta}(p)|
	* greater than the size of the page pool
		* swap some processes out
		* ![](http://bgshin.github.io/images/OSLEC25B.png)
	* much less than the size of the pool, bring processes off the swap device
	* 