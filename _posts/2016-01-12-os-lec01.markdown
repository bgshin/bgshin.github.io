---
layout: post
title:  "OS Lecture 01"
date:   2016-01-12 14:30:00 -0500
categories: cs580
---


## logistics
* 공룡 9th edition - 시험은 책에서 
* Friday, 29th Apr 3PM


## History of OS

* No OS
	* Each program controls the entire computer
	* Programmer & operatoer same
	* loads program from media
	* process start 
	* debug with lights & switches
	* very poor unilization
* batch monitor
	* small control program loaded into high memory
	* reads in job cards transaction and data
	* jump into loaded code

	```bash
			|batch mon|
			----------
			|         |
	c1,cn->|         | ->printer
			|         |
			----------
			card (op code),... , card(data),.., card(end of job)
	```
	* I/O routines
	* program failure dumps memory
	* increases utilization
	* separates operation from programmer

> An OS is a program that controls the resources of a computing system for convinience and efficiency

* problem - peripherals show compared to CPU
* solution
	* faster peripherals - offline peripherals
	* replace slow peripherals with fast ones that are loaded offline

* problem - still too slow
* solution
	* use smart devices with buffering
	
	```bash
	  |CPU|  |MEM|  |I/O dev|
	    |      |        |
	  ------------------------
	```
	* DMA - direct mem access
		* IO dev can r/w mem directly
		
	```bash
	    |MEM|  |I/O dev|
	      |        |
	  -------------------
	```	
	
	* overlaps computation of I/O

* problem - CPU still too fast and fills all the buffers 
* solution
	* more buffers - spooling
	* add a fast memory device 
		* faster than peripherals
		* slower/bigger/cheaper than RAM
		* eg: spooling disk drive

	
	```bash
	  |CPU|  |MEM|  |I/O dev|   |spooling dd|
	    |      |                   |
	  -----------------------------------------
	```
	
* problem - spooling device fills up
* solution
	* multiprogramming
		* keep several programs in mem and switch b/w them
		* when one is wating for I/O another can do computation

### Time sharing
	* computer with a human doing I/O
	* multiprogramming is essential

	
### distributed systems
* limit to CPU speed
	* cost gets prohibitive
	* use multiple CPUs
		* tightly coupled direction
			* multiple cores
			* multiple chips
		* the other one
			* multiple computers with a n/w connectino

### Real time OS
* runs on systems and instruments that control h/w 
	* lab equipment
	* guidance systems
	* appliances, etc
* OS gives guatantees to system calls


* Batch - 1950 - 1060's
* Spooling - early 1960's
* multiprogramming - multics 1965
* time sharing - UNIX 1970's
* PC's - late 1970s - batch (DOS is screen version of batch)
* PC's spooling - 1980's (MS-DOS)
* PC's multiprogramming - 1995 (windows 95)


### Reading
* HOCA handout

### NEXT
* queue module (Thurs)
* edgar sergio Simulators (Tues)

