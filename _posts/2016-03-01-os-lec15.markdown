---
layout: post
title:  "OS Lecture 15"
date:   2016-03-01 14:30:00 -0500
categories: cs580
---



## I/O devices
* Dev Max # devReg
* Terminals 5 0-4 0x1400
* Printers 2 0-1 0x1450
* Disks 4 0-3 0x1470
* Floppy 4 0-3 0x14b0
* Clock 1 0

* 0x1400 + 5*16bytes = 0x1450
* 16bytes = 4 registers
* OP
* DA
* BA
* Status


* Nucleus & Devices
* Pass up interrupts
* Nucleus has one semaphore for each device
* Devices have absolute #'s 0-14
* when a process wants to wait for a dev, the nucleus P's that semaphore
* when a device interrupts the nucleus V's the semaphore

* P하는 이유
	* 다른놈 기회주려고
	* 디바이스 기다리려고
	* 씨피유 아끼려고

* Pseudo clock
	* SW clock that allows processes to sleep
	* Nucleus maintains a semaphore for it
		* Nuclues V's semaphore every 100ms
		* To sleep a process has the nucleus P that semaphore

		
* wait _for_ clock (SYS7)
* wait for IO device (SYS8)
	*  D4 <- device#
	*  D2-> lenth reg
	*  D3-> status reg
*  
* EVT - STLD - 
* 프로세스가 셈압하지 뉴클이하는게아님
* 셈맥스는 정해져있지만 어짜피 min(실제도는 세마포, 실제프로세스갯수)보다는 작다
	* 프로세스가 셈을 하므로 프로세스갯수와 관계있는듯 (52:00)

	
*	Process가 IO를 하는것임 뉴클은 안함
	* pokes param into 
		* 2dn IO reg (len)
		* 3rd IO reg (BA)
	* pokes an opcode - decive up and running
	* SYS8
	* 죽었다가 디바이스 인터럽하면 살아남
	* 또는 죽기전에 인터럽걸려서 살아날게 없던지? 59:00
	* 즉 인터럽이 먼저오던지 SYS8이 먼저오던지 (둘다 핸들링해야함)


* OS has an table
	* ![](/images/OSLEC15A.png)
